---
title: PV 操作与同步问题
date: 2018-10-11
---
###问题引入
在操作系统的多线程中，如何保证多个线程都对数据操作的一致性是我们需要考虑的问题。数据的不一致性主要体现在
* 不可重复读 两次读到的数据不一致
* 丢失修改 对数据进行操作之后，之后的数据又发生变化
* 读到脏数据 读到一个数据之后，该数据被改动

所以，我们针对这些并发性问题，可以引入信号量(semphore)来协调进程之间的竞争关系。

信号量可以看作对一个资源的抽象描述，类型为整数类型，可以取负数，他描述了可用资源的数量。当信号量为负数时，其绝对值表示的是等待的进程数量。
对信号量的操作，我们只允许 P 操作和 V 操作，并且，这两个操作都是原子操作即他们两个不能互相中断对方。
### P 操作和 V 操作的实现 
现在对 P 操作和 V 操作进行定义：
由于我们是对一个资源 S 进行操作，我们希望，如果 S 存在的时候，我们可以继续对数据进行操作，当 S 消耗完的时候，接下来对数据的操作无法进行，即进程被堵塞。我们可以把 S 看成对访问数据的一个保护，如果 S 存在，可以对数据操作，如果 S 消耗完，不能对数据进行操作。
所以，P 的逻辑可以定义为，如果 S 不存在，则等待，如果 S 存在，把 S 变小，即资源的值被消耗，然后对需要的数据进行访问。
同样的，V 的逻辑可以定义为，把 S 增大，即对资源的值释放。
可以得到这样的具体实现
```
P(s): while (s <= 0) wait;
      s --;
    
V(s): s ++;    
```
但其实，这段代码存在忙等的现象，即当 s 为初始化为 0时，进入 p 操作，此时，进入等待状态，如果没有 v 操作，此时，这个线程陷入等待。而对 s 的占用和释放是一个线程应具备的两个对应的操作，根据逻辑上而言，一个线程不可能会先做对需要资源做释放，然后在做占用操作。所以，当另一个线程对 s 做操作时，也只能做 p 操作，不可能先出现 v 操作，即这个进入等待的线程出现自旋锁。

所以，代码应该成如下的形式
```
P(s): s --;
    if s < 0:
        wait();
V(s): s++;
    if s <= 0:
        wakeup(wait_queue);        
```

这个时候，两个操作都是先对 s 进行操作，然后在判断 s 的值，决定是否堵塞进程还是唤醒进程。需要注意的是，堵塞进程和唤醒进程的条件是不一样的，在 p 操作时，当` s < 0 `的时候，才会堵塞进程，因为是先对 s 的值进行操作，所以，`s < 0` 则之前必有 `s <= 0` ,没有资源，自然应该进入等待队列。而在 v 操作时，当 ` s <= 0 `的时候，我们进行唤醒操作，对 s 操作之前必有 s 的值为 `s < 0` 说明有进程在等待队列，所以从等待队列中唤醒一个进程。

###读者和写者问题
读者和写者问题定义了数据库操作模型，他定义了一个问题场景，对于一组数据，有读者和写者两个角色，其中，读者可以读取数据，写者可以修改数据。在引入多线程之后，如何保证不会出现读到脏数据，不可重复读和丢失修改是我们应该考虑的问题。所以，我们应该对读者和写者之间作出互斥规定，避免出现这三类问题。
####第一类读者和写者问题（读者优先）
定义读者和写者之间的操作有以下的关系：
1. 当有读者在读时，其他读者也可以读
2. 当有读者读时，其他写者不能写，当有写者在写时，其他读者不能读
3. 一个写者在写时，其他写者不允许写
4. 当读者在读时且写者在等待读者读时，后来的读者可以跳过等待的写者继续读

这四条规则定义了第一类读者和写者问题，如何定义他们的操作来保证不会出现上述的三个问题是我们的任务。
这里，读者和写者是互斥关系，一个在读时，另一个不能写，一个在写时，另一个不能读，所以我们可以定义一个共同的信号量 `mutex` 控制他们互斥关系。写者之间也是互斥关系，但我们也可以使用 `mutex` 控制他们之间的互斥。读者之间允许同时读，所以，如果对读者也使用 `mutex` 控制的话， 会出现读者的互斥，所以，我们使用 `readingCount` 去控制 `mutex` , `readingCount` 表示读者的数量。但读者操作的时候需要对 `readingCount` 进行修改，这样在读者之间需要保证 `readingCount` 数量的同步，所以，需要设置信号量 
`enable_read` 控制读者对 `readingCount` 的修改。

````
void Reader(){
    while(1){
        p(enable_read);
        readingCount ++;
        if (readingCount == 1)
            p(mutex);     
        v(enable_read);
        do_read();
        p(readingCount);
        readingCount --;
        if (readingCount == 0)
            v(mutex);
        v(readingCount);
    }
```` 

````
void writer() {
    while(1) {
        p(mutex);
        do_write();
        v(mutex);
    }
}
````
####第二类读者和写者问题（写者优先）
读者优先策略可能会导致写者饿死的情况出现，即写者可能永远不能得到资源，所以，我们可以采取写者优先策略。
写者优先策略定义的读者写者之间关系如下：
1. 读者之间可以同时读
2. 写者和读者互斥
3. 写者之间互斥
4. 当读者和写者同时等待时，优先唤醒写者

mutex, enable_read, readingCount, enable_entry


写者优先的策略可以引入一个 `writingCount` 记录写者个数，当 `writingCount` 等于 0 时，允许读者读，否则禁止读者读，此时，如果用 `mutex` 控制禁止读者读，可能会影响写者本身的写允许，所以引入一个信号量 `enable_entry` 控制允许读者读，同时读者之间需要修改 `writingCount`，所以引入 `enable_write` 控制写者对 `writingCount` 的互斥操作。如果出现读者在等待读的时候，后续出现一个写者，我们需要让写者优先被唤醒，所以需要一个信号量 `skip` 让读者进入等待，即每次只有一个读者可以进入。

```
void reader() {
    while(1){
        p(skip)
        p(enable_entry);
        p(enable_read);
        readingCount ++;
        if (readingCount == 1)
            p(mutex);
        v(enable_read);
        v(enable_entry);
        v(skip)
        read();
        p(enable_read);
        readingCount --;
        if (readingCount == 0)
            v(mutex);
        v(enable_read);
    }
}
```

```
void writer(){
    while(1){
        p(enable_write);
        writingCount ++;
        if (writingCount == 1)
            p(enable_entry);
        v(enable_write);
        p(mutex);
        write();
        v(mutex);
        p(enable_write);
        writingCount --;
        if (writingCount == 0)
            v(enable_entry);
        v(enable_write);
    }
}
```

