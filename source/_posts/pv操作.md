---
title: PV 操作与同步问题
date: 2018-10-11
---
####问题引入
在操作系统的多线程中，如何保证多个线程都对数据操作的一致性是我们需要考虑的问题。数据的不一致性主要体现在
* 不可重复读 两次读到的数据不一致
* 丢失修改 对数据进行操作之后，之后的数据又发生变化
* 读到脏数据 读到一个数据之后，该数据被改动

所以，我们针对这些并发性问题，可以引入信号量(semphore)来协调进程之间的竞争关系。

信号量可以看作对一个资源的抽象描述，类型为整数类型，可以取负数，他描述了可用资源的数量。当信号量为负数时，其绝对值表示的是等待的进程数量。
对信号量的操作，我们只允许 P 操作和 V 操作，并且，这两个操作都是原子操作即他们两个不能互相中断对方。
#### P 操作和 V 操作的实现 
现在对 P 操作和 V 操作进行定义：
由于我们是对一个资源 S 进行操作，我们希望，如果 S 存在的时候，我们可以继续对数据进行操作，当 S 消耗完的时候，接下来对数据的操作无法进行，即进程被堵塞。我们可以把 S 看成对访问数据的一个保护，如果 S 存在，可以对数据操作，如果 S 消耗完，不能对数据进行操作。
所以，P 的逻辑可以定义为，如果 S 不存在，则等待，如果 S 存在，把 S 变小，即资源的值被消耗，然后对需要的数据进行访问。
同样的，V 的逻辑可以定义为，把 S 增大，即对资源的值释放。
可以得到这样的具体实现
```
P(s): while (s <= 0) wait;
      s --;
    
V(s): s ++;    
```
但其实，这段代码存在忙等的现象，即当 s 为初始化为 0时，进入 p 操作，此时，进入等待状态，如果没有 v 操作，此时，这个线程陷入等待。而对 s 的占用和释放是一个线程应具备的两个对应的操作，根据逻辑上而言，一个线程不可能会先做对需要资源做释放，然后在做占用操作。所以，当另一个线程对 s 做操作时，也只能做 p 操作，不可能先出现 v 操作，即这个进入等待的线程出现自旋锁。

所以，代码应该成如下的形式
```
P(s): s --;
    if s < 0:
        wait();
V(s): s++;
    if s <= 0:
        wakeup(wait_queue);        
```

这个时候，两个操作都是先对 s 进行操作，然后在判断 s 的值，决定是否堵塞进程还是唤醒进程。需要注意的是，堵塞进程和唤醒进程的条件是不一样的，在 p 操作时，当` s < 0 `的时候，才会堵塞进程，因为是先对 s 的值进行操作，所以，`s < 0` 则之前的 `s <= 0` ,没有资源，自然应该进入等待队列。而在 v 操作时，当 ` s <= 0 `的时候，我们进行唤醒操作，对 s 操作之前的 s 的值为 `s < 0` 说明有进程在等待队列，所以从等待队列中唤醒一个进程。